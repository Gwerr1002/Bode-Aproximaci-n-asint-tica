# -*- coding: utf-8 -*-
"""Bode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SVvkqk9FwgnQFyOZlMKeghselg82cF2s
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy.signal as sps


class BodeAprox:
    def __init__(self,num,den):
        self.rnum = np.round(np.roots(num),5)
        self.rden = np.round(np.roots(den),5)
    def plot(self):
        polys_d=self.extP(self.rden)
        polys_n=self.extP(self.rnum)
        WcO_d = self.getWcO(polys_d)
        WcO_n = self.getWcO(polys_n)
        K=20*np.log10((num[num>0][-1] if num[-1]!=0 else 1)/(den[den>0][-1] if den[den>0][-1]!=0 else 1))
        mami=np.append(WcO_d,WcO_n)
        decs = self.vdec(mami)
        mi,ma= decs.min()-1,decs.max()+2
        w = np.logspace(mi,ma,1000)
        w,H,p = sps.bode((num,den),w)
        self._initPlot(w, H, mi, ma, WcO_d, WcO_n, K, p)
    def extP(self,lroots):
        M=np.abs(lroots)
        u=np.unique(M)
        p=[]
        for v in u:
            vec=lroots[M==v]
            if len(vec)>1:
                vec=np.poly(vec)
            else:
                vec=np.append([1],-vec).real
            p.append(vec)
        return p
    def getWcO(self,p):
        return np.array([[np.sqrt(pol[-1]),len(pol)-1] if len(pol)-1==2 else [pol[-1],len(pol)-1] for pol in p])
    def dec(self,wc):
        if wc !=0:
            scale,wc = (1,wc) if wc>=1 else (-1,1/wc)
            d = 0
            while wc!=0:
                wc//=10
                d+=scale
            return d
        else:
            return 0
    def vdec(self,wc):
        f=np.vectorize(self.dec)
        return f(wc)
    def plotAproxMag(self,wcc,axes,mi,ma,tipo):
        a = -1 if tipo == 'p' else 1
        wp = np.logspace(mi,ma,1000)
        tot = np.zeros_like(wp)
        for wc,o in wcc:
            pp = np.zeros_like(wp)
            b = a*20*o
            pp[wp>=wc] += b*np.log10(wp[wp>=wc]/(wc if wc>0 else 1))
            axes.semilogx(wp,pp, linestyle='--',label=f'$\omega_c$={wc:.3f}   N={o}')
            tot += pp
        return wp, tot
    def plotAproxPha(self,wcc,axes,mi,ma,tipo):
        a = -1 if tipo == 'p' else 1
        wp = np.logspace(mi,ma,1000)
        tot=np.zeros_like(wp)
        for wc,o in wcc:
            ph=np.zeros_like(wp)
            s =((wp>=wc/10) & (wp<=wc*10))
            if wc>0:
                ph[s]+=o*a*45*np.log10(wp[s]/(wc/10))
                ph[wp>=wc*10]=o*a*90
            else:
                ph+=a*o*90
            tot+=ph
            axes.semilogx(wp,ph,linestyle='--',label=f"$\omega_c$={wc:.3f}   N={o}")
        return wp,tot
    def _initPlot(self,w,H,mi,ma,WcO_d,WcO_n,K,p):
        fig,ax = plt.subplots(2,1)
        #
        ax[0].semilogx(w,H,linewidth=3,label='Real')
        wp,tot1 = self.plotAproxMag(WcO_d,ax[0],mi,ma,'p')
        wp,tot2 = self.plotAproxMag(WcO_n,ax[0],mi,ma,'z')
        ax[0].axhline(K,label=f'k={K:.3f}',linestyle='--',c='gray',linewidth=2)
        ax[0].semilogx(wp,K+tot1+tot2,c='black',linewidth=2,label='Aproximaci贸n',linestyle='--')
        ax[0].legend()
        ax[0].grid(linestyle='--',c='gray',which="both")
        ax[0].set_ylabel(r'$|H(j\omega)|_{dB}$',fontsize=13)
        #
        ax[1].semilogx(w,p,linewidth=3,label='Real')
        wp,tot1 = self.plotAproxPha(WcO_n,ax[1],mi,ma,'z')
        wp,tot2 = self.plotAproxPha(WcO_d,ax[1],mi,ma,'p')
        ax[1].semilogx(wp,tot1+tot2,c='black',linewidth=2,label='Aproximaci贸n',linestyle='--')
        ax[1].legend()
        ax[1].grid(linestyle='--',c='gray',which="both")
        ax[1].set_xlabel('$\omega_{(rad/seg)}$',fontsize=13)
        ax[1].set_ylabel(r'$\phi ( \theta )_{(DEG)}$',fontsize=13)
        plt.suptitle("Bode: Aproximaci贸n asint贸tica",fontsize=15)
        plt.tight_layout()
        figManager = plt.get_current_fig_manager()
        figManager.window.showMaximized()
        #plt.tight_layout()
        plt.show()

if __name__=='__main__':
    numerador = [1,0,0]#np.convolve([10,20],[1,100])
    denominador = np.poly([-10,-10,-100+100j,-100-100j])#np.convolve([1,0],[1,4,100])
    B = BodeAprox(numerador, denominador)
    B.plot()
